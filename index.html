<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Game of Life - Pro Controls</title>
    <style>
        body { margin: 0; background: #f0f0f0; color: #333; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; display: flex; }
        #sidebar { width: 260px; height: 100vh; background: rgba(255,255,255,0.95); border-right: 1px solid #ddd; display: flex; flex-direction: column; z-index: 20; box-shadow: 2px 0 10px rgba(0,0,0,0.05); backdrop-filter: blur(10px); flex-shrink: 0; }
        .sidebar-header { padding: 20px; border-bottom: 1px solid #eee; font-weight: bold; font-size: 1.1em; }
        .storage-btns { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; padding: 10px; border-bottom: 1px solid #eee; }
        #shape-list { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .shape-item { padding: 10px; border: 1px solid #eee; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.85em; display: flex; justify-content: space-between; align-items: center; }
        .shape-item:hover { background: #f0f7ff; border-color: #4a90e2; }
        .delete-btn { background: #fff0f0; border: 1px solid #ffcccc; color: #d9534f; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.9em; }
        #controls { position: absolute; top: 20px; left: 280px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; z-index: 10; border: 1px solid #ddd; box-shadow: 0 8px 32px rgba(0,0,0,0.1); width: 220px; }
        canvas { flex-grow: 1; display: block; cursor: crosshair; }
        .row { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
        input[type="range"] { width: 100%; accent-color: #4a90e2; cursor: pointer; }
        label { font-size: 0.75em; font-weight: 700; color: #888; text-transform: uppercase; }
        button { cursor: pointer; padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 6px; transition: all 0.2s; font-size: 0.85em; }
        button.active { background: #4a90e2; color: white; border-color: #2a70c2; }
        .btn-group { display: flex; gap: 5px; width: 100%; }
        .hint { font-size: 0.7em; opacity: 0.7; border-top: 1px solid #eee; padding-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="sidebar-header">Shape Library</div>
    <div class="storage-btns">
        <button id="exportBtn">Export</button>
        <button id="importBtn">Import</button>
    </div>
    <input type="file" id="fileInput" style="display:none" accept=".json">
    <div id="shape-list"></div>
</div>

<div id="controls">
    <div class="btn-group"><button id="playPause">Play (Space)</button></div>
    <div class="btn-group">
        <button id="selectModeBtn">Select</button>
        <button id="drawModeBtn" class="active">Draw</button>
    </div>
    <button id="centerBtn">Center (R)</button>
    <div class="btn-group">
        <button id="back">← Back</button>
        <button id="step">Step →</button>
    </div>
    <div class="row">
        <label>Zoom (Q/E)</label>
        <input type="range" id="zoom" min="5" max="150" value="30">
    </div>
    <div class="row">
        <label>Speed</label>
        <input type="range" id="speed" min="10" max="500" value="100" dir="rtl">
    </div>
    <button id="clear" style="color: #d9534f;">Clear Grid</button>
    <div class="hint">
        <b>WASD:</b> Move camera<br>
        <b>Q / E:</b> Zoom Out / In<br>
        <b>R:</b> Snap to Population
    </div>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
const shapeListEl = document.getElementById('shape-list'), zoomInput = document.getElementById('zoom'), speedInput = document.getElementById('speed');

let cellSize = 30, grid = new Set(), history = [], shapeLibrary = [];
let isPlaying = false, lastTick = 0, cameraX = 0, cameraY = 0;
let mode = 'draw', isDraggingOnCanvas = false, selectionStart = null, selectionEnd = null;
let currentClipboard = null, drawModeType = true, lastMousePos = null;

const keys = {};
window.onkeydown = (e) => { 
    keys[e.code] = true;
    if (e.code === 'KeyR') centerOnPopulation();
    if (e.code === 'ArrowRight') step();
    if (e.code === 'ArrowLeft' && history.length) { grid = history.pop(); render(); }
    if (e.code === 'Space') { e.preventDefault(); document.getElementById('playPause').click(); }
    if (e.code === 'Escape') document.getElementById('drawModeBtn').click();
};
window.onkeyup = (e) => keys[e.code] = false;

function getCoord(x, y) { return `${x},${y}`; }
function screenToGrid(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((clientX - rect.left - canvas.width / 2 - cameraX) / cellSize);
    const y = Math.floor((clientY - rect.top - canvas.height / 2 - cameraY) / cellSize);
    return { x, y };
}

function updateLibraryUI() {
    shapeListEl.innerHTML = shapeLibrary.length === 0 ? '<div style="font-size: 0.8em; color: #999; text-align: center; margin-top: 20px;">Use Select Mode to save shapes.</div>' : '';
    shapeLibrary.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'shape-item';
        div.innerHTML = `<div class="shape-info"><span class="shape-name">${item.name}</span><span class="shape-meta">${item.pattern.length} cells</span></div><button class="delete-btn">×</button>`;
        div.onclick = () => { currentClipboard = item.pattern; mode = 'paste'; document.querySelectorAll('button').forEach(b => b.classList.remove('active')); };
        div.querySelector('.delete-btn').onclick = (e) => { e.stopPropagation(); shapeLibrary.splice(index, 1); localStorage.setItem('gol_library', JSON.stringify(shapeLibrary)); updateLibraryUI(); };
        shapeListEl.appendChild(div);
    });
}

function centerOnPopulation() {
    if (grid.size === 0) { cameraX = 0; cameraY = 0; return; }
    let sumX = 0, sumY = 0;
    grid.forEach(k => { const [x, y] = k.split(',').map(Number); sumX += x; sumY += y; });
    cameraX = -(sumX / grid.size) * cellSize;
    cameraY = -(sumY / grid.size) * cellSize;
}

function step() {
    history.push(new Set(grid)); if (history.length > 60) history.shift();
    const newGrid = new Set(), counts = new Map();
    grid.forEach(k => {
        const [gx, gy] = k.split(',').map(Number);
        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
            if(i===0 && j===0) continue;
            const nk = getCoord(gx+i, gy+j);
            counts.set(nk, (counts.get(nk) || 0) + 1);
        }
    });
    counts.forEach((c, k) => { if(c===3 || (c===2 && grid.has(k))) newGrid.add(k); });
    grid = newGrid;
}

function saveSelection() {
    if (!selectionStart || !selectionEnd) return;
    const x1 = Math.min(selectionStart.x, selectionEnd.x), y1 = Math.min(selectionStart.y, selectionEnd.y);
    const x2 = Math.max(selectionStart.x, selectionEnd.x), y2 = Math.max(selectionStart.y, selectionEnd.y);
    const pattern = [];
    for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) if (grid.has(getCoord(x, y))) pattern.push({ x: x - x1, y: y - y1 });
    if (pattern.length === 0) return;
    const name = prompt("Name your shape:", `Shape ${shapeLibrary.length + 1}`);
    if (name) { shapeLibrary.push({ name, pattern }); localStorage.setItem('gol_library', JSON.stringify(shapeLibrary)); updateLibraryUI(); }
    selectionStart = null; selectionEnd = null;
}

canvas.addEventListener('mousedown', (e) => {
    isDraggingOnCanvas = true; const pos = screenToGrid(e.clientX, e.clientY);
    if (mode === 'draw') { drawModeType = !grid.has(getCoord(pos.x, pos.y)); const k = getCoord(pos.x, pos.y); if(drawModeType) grid.add(k); else grid.delete(k); }
    else if (mode === 'select') { selectionStart = pos; selectionEnd = pos; }
    else if (mode === 'paste' && currentClipboard) { currentClipboard.forEach(c => grid.add(getCoord(pos.x + c.x, pos.y + c.y))); mode = 'draw'; document.getElementById('drawModeBtn').click(); }
});

window.addEventListener('mousemove', (e) => { lastMousePos = { x: e.clientX, y: e.clientY }; if (isDraggingOnCanvas && mode === 'select') selectionEnd = screenToGrid(e.clientX, e.clientY); });
window.addEventListener('mouseup', () => { if (isDraggingOnCanvas && mode === 'select') saveSelection(); isDraggingOnCanvas = false; });

function render() {
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    const cx = canvas.width / 2 + cameraX, cy = canvas.height / 2 + cameraY;
    ctx.beginPath(); ctx.strokeStyle = '#f0f0f0';
    for (let x = cx % cellSize; x < canvas.width; x += cellSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
    for (let y = cy % cellSize; y < canvas.height; y += cellSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
    ctx.stroke();
    ctx.fillStyle = '#4a90e2';
    grid.forEach(k => { const [x, y] = k.split(',').map(Number); ctx.fillRect(cx + x * cellSize + 1, cy + y * cellSize + 1, cellSize - 2, cellSize - 2); });
    if (mode === 'select' && selectionStart && selectionEnd) {
        const x1 = Math.min(selectionStart.x, selectionEnd.x), y1 = Math.min(selectionStart.y, selectionEnd.y);
        const x2 = Math.max(selectionStart.x, selectionEnd.x), y2 = Math.max(selectionStart.y, selectionEnd.y);
        ctx.strokeStyle = '#4a90e2'; ctx.setLineDash([5, 5]);
        ctx.strokeRect(cx + x1 * cellSize, cy + y1 * cellSize, (x2 - x1 + 1) * cellSize, (y2 - y1 + 1) * cellSize);
        ctx.setLineDash([]); ctx.fillStyle = 'rgba(74, 144, 226, 0.1)';
        ctx.fillRect(cx + x1 * cellSize, cy + y1 * cellSize, (x2 - x1 + 1) * cellSize, (y2 - y1 + 1) * cellSize);
    }
    if (mode === 'paste' && currentClipboard && lastMousePos) {
        ctx.globalAlpha = 0.4; const {x: gx, y: gy} = screenToGrid(lastMousePos.x, lastMousePos.y);
        currentClipboard.forEach(c => ctx.fillRect(cx + (gx + c.x) * cellSize + 1, cy + (gy + c.y) * cellSize + 1, cellSize - 2, cellSize - 2));
        ctx.globalAlpha = 1.0;
    }
}

function loop(t) {
    // Movement Logic
    const moveSpeed = 15;
    if (keys['KeyW']) cameraY += moveSpeed; if (keys['KeyS']) cameraY -= moveSpeed;
    if (keys['KeyA']) cameraX += moveSpeed; if (keys['KeyD']) cameraX -= moveSpeed;
    
    // Zoom Logic (Q/E)
    if (keys['KeyQ'] && cellSize > 5) cellSize -= 1;
    if (keys['KeyE'] && cellSize < 150) cellSize += 1;
    zoomInput.value = cellSize; // Sync slider

    if (isPlaying && t - lastTick > parseInt(speedInput.value)) { step(); lastTick = t; }
    render(); requestAnimationFrame(loop);
}

document.getElementById('centerBtn').onclick = centerOnPopulation;
document.getElementById('selectModeBtn').onclick = () => { mode = 'select'; selectModeBtn.classList.add('active'); drawModeBtn.classList.remove('active'); selectionStart = null; };
document.getElementById('drawModeBtn').onclick = () => { mode = 'draw'; drawModeBtn.classList.add('active'); selectModeBtn.classList.remove('active'); selectionStart = null; };
document.getElementById('playPause').onclick = function() { isPlaying = !isPlaying; this.innerText = isPlaying ? "Pause" : "Play"; };
document.getElementById('clear').onclick = () => { grid.clear(); history = []; };
zoomInput.oninput = (e) => cellSize = parseInt(e.target.value);

const saved = localStorage.getItem('gol_library');
if (saved) { shapeLibrary = JSON.parse(saved); updateLibraryUI(); }
canvas.width = window.innerWidth - 260; canvas.height = window.innerHeight;
loop(0);
</script>
</body>
</html>
