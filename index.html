<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Game of Life - Stable Zoom</title>
    <style>
        body { margin: 0; background: #f0f0f0; color: #333; font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; display: flex; }
        #sidebar { width: 260px; height: 100vh; background: rgba(255,255,255,0.95); border-right: 1px solid #ddd; display: flex; flex-direction: column; z-index: 20; box-shadow: 2px 0 10px rgba(0,0,0,0.05); backdrop-filter: blur(10px); flex-shrink: 0; }
        .sidebar-header { padding: 20px; border-bottom: 1px solid #eee; font-weight: bold; font-size: 1.1em; }
        .storage-btns { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; padding: 10px; border-bottom: 1px solid #eee; }
        #shape-list { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .shape-item { padding: 10px; border: 1px solid #eee; border-radius: 6px; background: #fff; cursor: pointer; font-size: 0.85em; display: flex; justify-content: space-between; align-items: center; }
        .shape-item:hover { background: #f0f7ff; border-color: #4a90e2; }
        .delete-btn { background: #fff0f0; border: 1px solid #ffcccc; color: #d9534f; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.9em; }
        #controls { position: absolute; top: 20px; left: 280px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; z-index: 10; border: 1px solid #ddd; box-shadow: 0 8px 32px rgba(0,0,0,0.1); width: 220px; }
        canvas { flex-grow: 1; display: block; cursor: crosshair; }
        .row { display: flex; align-items: center; gap: 10px; justify-content: space-between; }
        input[type="range"] { width: 100%; accent-color: #4a90e2; cursor: pointer; }
        label { font-size: 0.75em; font-weight: 700; color: #888; text-transform: uppercase; }
        button { cursor: pointer; padding: 8px; background: #fff; border: 1px solid #ddd; border-radius: 6px; transition: all 0.2s; font-size: 0.85em; }
        button.active { background: #4a90e2; color: white; border-color: #2a70c2; }
        .btn-group { display: flex; gap: 5px; width: 100%; }
        .hint { font-size: 0.7em; opacity: 0.7; border-top: 1px solid #eee; padding-top: 5px; line-height: 1.4; }
    </style>
</head>
<body>
<div id="sidebar">
    <div class="sidebar-header">Shape Library</div>
    <div class="storage-btns">
        <button id="exportBtn">Export</button>
        <button id="importBtn">Import</button>
    </div>
    <input type="file" id="fileInput" style="display:none" accept=".json">
    <div id="shape-list"></div>
</div>
<div id="controls">
    <div class="btn-group"><button id="playPause">Play (Space)</button></div>
    <div class="btn-group">
        <button id="selectModeBtn">Select</button>
        <button id="drawModeBtn" class="active">Draw</button>
    </div>
    <div class="btn-group">
        <button id="back">← Back</button>
        <button id="step">Step →</button>
    </div>
    <div class="row">
        <label>Zoom (Q/E)</label>
        <input type="range" id="zoom" min="2" max="150" value="30">
    </div>
    <div class="row">
        <label>Speed</label>
        <input type="range" id="speed" min="10" max="500" value="100" dir="rtl">
    </div>
    <button id="clear" style="color: #d9534f;">Clear Grid</button>
    <div class="hint">
        <b>Hold R:</b> Smooth Auto-Track<br>
        <b>WASD:</b> Move camera<br>
        <b>Q / E:</b> Zoom Out / In
    </div>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
const shapeListEl = document.getElementById('shape-list'), zoomInput = document.getElementById('zoom'), speedInput = document.getElementById('speed');
let cellSize = 30, grid = new Set(), history = [], shapeLibrary = [];
let isPlaying = false, lastTick = 0;
// cameraX/Y now represent the grid coordinate that is at the center of the screen
let cameraX = 0, cameraY = 0;
let mode = 'draw', isDraggingOnCanvas = false, selectionStart = null, selectionEnd = null;
let currentClipboard = null, drawModeType = true, lastMousePos = null;

const keys = {};
window.onkeydown = (e) => { 
    keys[e.code] = true;
    if (['ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE'].includes(e.code)) e.preventDefault();
    if (e.code === 'ArrowRight') step();
    if (e.code === 'ArrowLeft' && history.length) { grid = history.pop(); render(); }
    if (e.code === 'Space') document.getElementById('playPause').click();
    if (e.code === 'Escape') document.getElementById('drawModeBtn').click();
};
window.onkeyup = (e) => keys[e.code] = false;

function getCoord(x, y) { return `${x},${y}`; }
function screenToGrid(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const rx = clientX - rect.left, ry = clientY - rect.top;
    const x = Math.floor((rx - canvas.width / 2) / cellSize + cameraX);
    const y = Math.floor((ry - canvas.height / 2) / cellSize + cameraY);
    return { x, y };
}

function updateLibraryUI() {
    shapeListEl.innerHTML = shapeLibrary.length === 0 ? '<div style="font-size: 0.8em; color: #999; text-align: center; margin-top: 20px;">Use Select Mode to save shapes.</div>' : '';
    shapeLibrary.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'shape-item';
        div.innerHTML = `<div class="shape-info"><span class="shape-name">${item.name}</span><span class="shape-meta">${item.pattern.length} cells</span></div><button class="delete-btn">×</button>`;
        div.onclick = () => { currentClipboard = item.pattern; mode = 'paste'; document.querySelectorAll('button').forEach(b => b.classList.remove('active')); };
        div.querySelector('.delete-btn').onclick = (e) => { e.stopPropagation(); shapeLibrary.splice(index, 1); localStorage.setItem('gol_library', JSON.stringify(shapeLibrary)); updateLibraryUI(); };
        shapeListEl.appendChild(div);
    });
}

function smoothTrack() {
    if (grid.size === 0) return;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    grid.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        if (x < minX) minX = x; if (x > maxX) maxX = x;
        if (y < minY) minY = y; if (y > maxY) maxY = y;
    });
    const padding = 4;
    const targetZoom = Math.min(canvas.width / ((maxX - minX) + padding), canvas.height / ((maxY - minY) + padding), 150);
    const targetCX = (minX + maxX) / 2;
    const targetCY = (minY + maxY) / 2;
    cellSize += (Math.max(2, targetZoom) - cellSize) * 0.1;
    cameraX += (targetCX - cameraX) * 0.1;
    cameraY += (targetCY - cameraY) * 0.1;
    zoomInput.value = cellSize;
}

function step() {
    history.push(new Set(grid)); if (history.length > 60) history.shift();
    const newGrid = new Set(), counts = new Map();
    grid.forEach(k => {
        const [gx, gy] = k.split(',').map(Number);
        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
            if(i===0 && j===0) continue;
            const nk = getCoord(gx+i, gy+j);
            counts.set(nk, (counts.get(nk) || 0) + 1);
        }
    });
    counts.forEach((c, k) => { if(c===3 || (c===2 && grid.has(k))) newGrid.add(k); });
    grid = newGrid;
}

canvas.addEventListener('mousedown', (e) => {
    isDraggingOnCanvas = true; const pos = screenToGrid(e.clientX, e.clientY);
    if (mode === 'draw') { drawModeType = !grid.has(getCoord(pos.x, pos.y)); const k = getCoord(pos.x, pos.y); if(drawModeType) grid.add(k); else grid.delete(k); }
    else if (mode === 'select') { selectionStart = pos; selectionEnd = pos; }
    else if (mode === 'paste' && currentClipboard) { currentClipboard.forEach(c => grid.add(getCoord(pos.x + c.x, pos.y + c.y))); mode = 'draw'; document.getElementById('drawModeBtn').click(); }
});

window.addEventListener('mousemove', (e) => { 
    lastMousePos = { x: e.clientX, y: e.clientY }; 
    if (isDraggingOnCanvas && mode === 'select') selectionEnd = screenToGrid(e.clientX, e.clientY); 
});

window.addEventListener('mouseup', () => { 
    if (isDraggingOnCanvas && mode === 'select' && selectionStart && selectionEnd) {
        const x1 = Math.min(selectionStart.x, selectionEnd.x), y1 = Math.min(selectionStart.y, selectionEnd.y);
        const x2 = Math.max(selectionStart.x, selectionEnd.x), y2 = Math.max(selectionStart.y, selectionEnd.y);
        const pattern = [];
        for (let x = x1; x <= x2; x++) for (let y = y1; y <= y2; y++) if (grid.has(getCoord(x, y))) pattern.push({ x: x - x1, y: y - y1 });
        if (pattern.length > 0) {
            const name = prompt("Name your shape:", `Shape ${shapeLibrary.length + 1}`);
            if (name) { shapeLibrary.push({ name, pattern }); localStorage.setItem('gol_library', JSON.stringify(shapeLibrary)); updateLibraryUI(); }
        }
        selectionStart = null; selectionEnd = null;
    }
    isDraggingOnCanvas = false; 
});

function render() {
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    const sw = canvas.width, sh = canvas.height;
    ctx.beginPath(); ctx.strokeStyle = '#f0f0f0';
    const startX = ((-cameraX * cellSize) % cellSize + cellSize) % cellSize + (sw / 2) % cellSize;
    for (let x = startX % cellSize; x < sw; x += cellSize) { ctx.moveTo(x, 0); ctx.lineTo(x, sh); }
    const startY = ((-cameraY * cellSize) % cellSize + cellSize) % cellSize + (sh / 2) % cellSize;
    for (let y = startY % cellSize; y < sh; y += cellSize) { ctx.moveTo(0, y); ctx.lineTo(sw, y); }
    ctx.stroke();
    ctx.fillStyle = '#4a90e2';
    grid.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        const screenX = (x - cameraX) * cellSize + sw / 2;
        const screenY = (y - cameraY) * cellSize + sh / 2;
        ctx.fillRect(screenX + 1, screenY + 1, cellSize - 2, cellSize - 2);
    });
    if (mode === 'select' && selectionStart && selectionEnd) {
        const x1 = Math.min(selectionStart.x, selectionEnd.x), y1 = Math.min(selectionStart.y, selectionEnd.y);
        const x2 = Math.max(selectionStart.x, selectionEnd.x), y2 = Math.max(selectionStart.y, selectionEnd.y);
        const sX1 = (x1 - cameraX) * cellSize + sw / 2, sY1 = (y1 - cameraY) * cellSize + sh / 2;
        ctx.strokeStyle = '#4a90e2'; ctx.setLineDash([5, 5]);
        ctx.strokeRect(sX1, sY1, (x2 - x1 + 1) * cellSize, (y2 - y1 + 1) * cellSize);
        ctx.setLineDash([]); ctx.fillStyle = 'rgba(74, 144, 226, 0.1)';
        ctx.fillRect(sX1, sY1, (x2 - x1 + 1) * cellSize, (y2 - y1 + 1) * cellSize);
    }
    if (mode === 'paste' && currentClipboard && lastMousePos) {
        ctx.globalAlpha = 0.4; const {x: gx, y: gy} = screenToGrid(lastMousePos.x, lastMousePos.y);
        currentClipboard.forEach(c => {
            const sX = (gx + c.x - cameraX) * cellSize + sw / 2;
            const sY = (gy + c.y - cameraY) * cellSize + sh / 2;
            ctx.fillRect(sX + 1, sY + 1, cellSize - 2, cellSize - 2);
        });
        ctx.globalAlpha = 1.0;
    }
}

function loop(t) {
    if (keys['KeyR']) { smoothTrack(); } else {
        const moveStep = 15 / cellSize; 
        if (keys['KeyW']) cameraY -= moveStep; if (keys['KeyS']) cameraY += moveStep;
        if (keys['KeyA']) cameraX -= moveStep; if (keys['KeyD']) cameraX += moveStep;
        if (keys['KeyQ'] && cellSize > 2) cellSize -= 1;
        if (keys['KeyE'] && cellSize < 150) cellSize += 1;
        zoomInput.value = cellSize;
    }
    if (isPlaying && t - lastTick > parseInt(speedInput.value)) { step(); lastTick = t; }
    render(); requestAnimationFrame(loop);
}

document.getElementById('selectModeBtn').onclick = () => { mode = 'select'; selectModeBtn.classList.add('active'); drawModeBtn.classList.remove('active'); selectionStart = null; };
document.getElementById('drawModeBtn').onclick = () => { mode = 'draw'; drawModeBtn.classList.add('active'); selectModeBtn.classList.remove('active'); selectionStart = null; };
document.getElementById('playPause').onclick = function() { isPlaying = !isPlaying; this.innerText = isPlaying ? "Pause" : "Play"; };
document.getElementById('clear').onclick = () => { grid.clear(); history = []; };
zoomInput.oninput = (e) => cellSize = parseInt(e.target.value);
const saved = localStorage.getItem('gol_library');
if (saved) { shapeLibrary = JSON.parse(saved); updateLibraryUI(); }
window.onresize = () => { canvas.width = window.innerWidth - 260; canvas.height = window.innerHeight; };
window.onresize();
loop(0);
</script>
</body>
</html>
